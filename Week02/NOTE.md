# 第二周学习笔记和心得
***
## L5 哈希表、映射和集合
  哈希表 Hash Table
- 散列表
- 根据key直接进行访问，通过将key映射到表中位置直接访问，查找快
- 映射函数-->**散列函数Hash Function**  
- 哈希**碰撞**：不同的key经过hash函数计算后得到相同的值  

好的hash函数（一般比较复杂），可以在将key计算后，减少碰撞。

**拉链式解决冲突法**：对于存储在hash表同一位置的内容，通过增加维度，在该位置增加一个列表存储内容。但是此时，在查询操作时需要在该位置遍历链表查询，导致效率退化（最差时候退化成列表，复杂度达到O(N)）  
#### 抽象实现 
- MAP （python中的dict）  
    **key-value键值对**  
    key唯一
- SET  
    **不重复元素的集合**

TreeMap\TreeSet在高级语言中以R-B Tree实现，复杂度为O(LogN)
***

## L6 树、二叉树和二叉搜索树
1. 树
- 根结点、儿子结点（左儿子&右儿子）、父亲结点、兄弟结点
- 子树
- 层

2. 二叉树
- 只有左右两个儿子结点的树
- 二叉树遍历：
    - 前序遍历 Pre-order：根-左-右
    - 中序 In-order：左-根-右
    - 后序 Post-order：左-右-根

3. 二叉搜索树 Binary Search Tree  
- 也称 二叉排序树、有序二叉树Ordered Binary Tree、排序二叉树Sorted BInary Tree。
    1. 左子树**所有结点**的值均**小于**根结点的值
    2. 右子树**所有结点**的值均**大于**根结点的值
    3. **重复性**：左右子树也分别为二叉搜索树  

- 二叉搜索树的**中序遍历**为**升序遍历**  
    
- **查询和操作的复杂度：O(LogN)**  
- 元素搜索：根据数值大小，小则进入左子树，大则进入右子树继续递归，直至找到元素或者元素不存在。
- 删除：如果删除元素为非叶子结点，可以用该节点左子树的最大值或者右子树的最小值填充至原结点（一般选择比删除元素大的最小元素，即右子树的最小值）

4. **其他**  
    - **链表是特殊化的树（只有一个结点）**  
    - **树是特殊化的图（没有环）**  
    - **状态变化的行为可以理解为树，例如：棋类游戏，星际争霸，乃至人类发展行为。**  

> **思考：为什么遍历树的结点是使用递归：**  
程序运行的三种基础操作是：分支、循环和递归。对于树型结构，通过分支和循环都不能比较简洁的实现所有树结点的遍历。而且树中的各个结点，有着相似的数据结构，这尤其匹配遍历的基础要求。因此，使用递归方法来遍历树结点是最为理想的。 

***
## L6 堆、二叉堆和图  
1. 堆 HEAP  
- 迅速找到一堆数中**最大**或**最小**的数据结构
- 根节点最大的堆叫大顶堆或大根堆（类推根节点最小）
- 常见堆有：二叉堆、斐波那契堆
- 常见操作(以大顶堆为例）及时间复杂度：  
    - find-max：   O(1)
    - delete-max： O(LogN)
    - insert(create): O(logN) or O(1) （斐波那契堆可以达到O(1)）
2. 二叉堆
- 通过完全二叉树来实现（**完全二叉树：除最深层外，其它各层 的结点数都达到最大个数，最深层所有的结点都连续集中在最左边**）
- （例如大顶堆）满足如下性质：
    - 是一棵完全树（**完全树：**）
    - 树中任意节点的值总是 >= 其子节点的值
- 二叉堆实现
    - 一般通过“数组”来实现
    - 假设“第一个元素”在数组的索引为0：
        - 索引i元素的左儿子节点索引为（2*i+1）
        - 索引i元素的右儿子节点索引为（2*i+2）
        - 索引i元素的父节点索引为floor((i-1)/2)
    - insert操作：
        - 新元素一律先插入到堆尾部
        - 依次向上调整整个堆的结构（HeapifyUP）：依次比较新元素值和父节点值的大小，若大于父节点值则向上浮动，直到不再大于父节点值停下
    - delete max操作：
        -  将堆尾元素替换到顶部
        -  依次从根部向下调整整个堆的结构（HeapifyDown）：父节点不断下沉到较大的儿子节点，直到停止。
- **二叉堆只是堆的一种简单常见实现，但在堆的各种实现中相对性能较一般，并不是最优的堆实现**
- 二叉堆一般可以使用各种语言中“优先队列priority_queue”的方式实现
3. 图
- Graph(V,E)
- V - vertex：点
    - 度：该点上有边的个数
        - 入度、出度：有向边（指入、指出）的个数
    - 点与点是否连通
- E - edge：边
    - 有向和无向
    - 权重
- 图的表示：通过邻接矩阵或邻接表这种二维矩阵的方式来表示图，其中：
    - 无向图的邻接矩阵横轴纵轴为点的index
    - 无向图的邻接矩阵按主对角线对称
    - 有向图的邻接矩阵出度对应元素值为1或权值，入度为0
    - 无权图的邻接矩阵元素值为0或1（0表示两个点不相连，1表示相连）
    - 有权图的邻接矩阵元素值为0或权值（0表示不相连）
- 常见算法
    - DFS：递归写法类似树，但要加上visited内容，记录已访问结点，防止重复访问。
    - BFS：LOOP写法类似树，同样也要增加visited内容。
    - 最短路径：Dijkstra
