## 第九周学习笔记和心得
***
### L19 高级动态规划
- 回顾动态规划的基础理论内容
- 最近重复子问题--可以理解为最大公约数，以防止子问题拆分的过小
- DP顺推模板
    ```
    def DP():
        dp = [][]  # 根据题意定义正确的DP状态数组。
        #分析题意后，根据需要确定包含的属性，来确定DP状态数组的维度。

        for i = range(M):
            for j in range(N):
                dp[i][j] = _function(dp[i'][j']....)
                # 关键：正确的状态转移方程

        # 最终需要的结果位置
        return dp[M][N]
    ```
### 高级DP
- 复杂度来源：
    - 状态的维度增加（甚至需要压缩）  
    - 状态方程变复杂
#### 思考题
- 不同路径II的状态转移方程：  
    思路：  
    1. 在m*n左侧和上侧增加一列0，解决边界的问题;  
    2. dp数组大小为 (m+1) * (n+1) 
    3. dp[1][1] 对应路径中的[0][0]点，即dp[i][j]和obs[i-1][j-1]对应

    dp[1][1] = 1, if (obs[0][0] != 1) # 起始点,且无障碍  
    在区间：i in range(1, m+1), j in range(1, n+1)中：  
        dp[i][j] = 0, if (obs[i-1][j-1] == 1)  # 有障碍  
        dp[i][j] = dp[i-1][j] + dp[i][j-1]     # 无障碍  
***
## L20 字符串算法
- Immutable：  
    Python和Java中，string是immutable（不可变的），改变内容时会创建新的字符串。好处在于线程安全。  
    C++中是可变的。（const 可以调整成为不可变）  
- 遍历字符串
- 字符串比较：
    注意比较的是内容还是指针，注意语言中具体的字符串比较方法。
- 高级的字符串问题，一般要结合DP，以及高级DP的思路解决。
### 字符串匹配算法
检查两个字符串：目标串txt，长度为M；子串pat，长度为N，是否匹配。
- 暴力法
    - 使用两层循环，检查对应字符是否一致
    - 时间复杂度 O(M * N)
    - 后面两种方法是基于暴力法进行优化。
- Rabin-Karp算法
    - 使用一个hash函数
    - 计算pat的hash值 hash_pat
    - 计算txt中 每个长度为 N 的子串的hash值（共需计算 M-N+1 次)
    - 如果hash值不同，必然不匹配；如果hash值相同，使用简单检查确认每一位字符是否相同。
    - 设计思路：
        1. 字符个数为256个，设计每一位的权重D=256
        2. 取一个稍大的素数作为模，防止计算值太大溢出，例如Q=9997（过小会造成碰撞）
        3. 不断移出高位字符，加入新字符时，为方便简化计算，先求出高位的HIGHESTPOW
        4. 不断移动N长度子串时，更新子串的hash值  
        hash = (D * (hash - oldchar * HIGHESTPOW) + newchar) % Q  
        如果hash小于零的话，加上Q保证为正。
- KMP算法
    - 当子串和目标串不匹配的时候，根据已经检查过的内容，不要过于往前回退待比较的起始位置。而是根据已经比较过的信息，把“搜索位置”尽量向后，再进行搜索，以提高效率。
    - 方法：
        1. 先针对pat算出长度为N的prefix_table（每一位的最长公共前后缀长度）
        2. 将prefix_table最后一位移出，第一位移入值-1，长度仍为N
        3. 遍历检查txt[i]和pat[j]的字符是否相同，当出现字符不同时，取出当前pat位对应的prefix_table[j]值，作为pat的下标，继续向后检查，txt[i]和pat[prefix_table[j]]
        4. 依次类推
        5. 若prefix_table[j] == -1, 向后检查txt[i+1]和pat[prefix_table[j]+1]  
        *[文字描述好难啊。。。多看几遍视频学习理解吧]*